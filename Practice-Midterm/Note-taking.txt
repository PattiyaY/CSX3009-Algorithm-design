Important!
    Recursive 
	import sys
	sys.setrecursionlimit(10000)
    
    Run Time
	import time 
	start = time.process_time()
	finish = time.process_time()
	print("running time =", finish-start)

---------------------------------------------------------------------------------------------------------

Memoization: This is a top-down approach where the function is called recursively and results are stored in a cache (or memo) to avoid recomputation. Memoization only computes the necessary subproblems that are encountered during the recursion.

Dynamic Programming (DP): This is a bottom-up approach where all subproblems are solved in advance and stored in a table (or array). It iteratively builds up solutions from the smallest subproblems to the desired problem.

Performance Comparison
Time Complexity: Both memoization and DP generally have the same time complexity because they solve each subproblem only once. For example, both approaches typically result in O(n) time complexity for problems like the rod cutting or coin change problem.

Space Complexity: Both approaches use additional space to store intermediate results. Memoization uses a cache, while DP uses a table. The space complexity is usually the same, O(n).

Overhead:
Memoization: Has a bit of overhead due to recursion and cache lookups. The recursive calls add function call overhead, which can be significant for deep recursion.

Dynamic Programming: Typically has less overhead because it uses simple iterative loops. This can make DP slightly faster in practice, especially for problems with many subproblems.

Stack Overflow Risk: Memoization can risk hitting the maximum recursion depth for problems that involve deep recursion, while DP, being iterative, avoids this issue.
---------------------------------------------------------------------------------------------------------

# Worksheet 1
Maximum contiguous subsequence
	â€¢	Preliminary: write code to reads a sequence of numbers and store in the list of integers

Input -> -2 -3 4 -1 -2 1 5 -3
Output -> (4+(-1)+(-2)+1+5) = 7

Approach 1 : Straightforward solution
def Sum(numList, i, j):     
    s = 0     
    for k in range(i, j + 1):       
        s += numList[k]     
    return s

maxVal = 0
numbers = list(map(int,input().split()))

for i in range(len(numbers)):
    for j in range(i,len(numbers)):
	    maxVal = max(maxVal, Sum(numbers, i, j))
print(maxVal)


Explanation 
	- 1st reads input and store in integers list and set maxVal = 0
	- 2nd we would like to know what's max value of a specific sequence
	  that's why we loop from index i to j which will check every number and sequences.
	- 3rd store the max value and keep comparing until last sequence.


Approach 2 : Accumulation techniques
Accumulation is the transformation of numbers
For example
    Input -> -2 -3 4 -1 -2 1 5 -3 transform to be -2 -5 -1 -2 -4 -3 2 -1

** i to j no need to be compute in the loop, so we need to modify the function.

def Sum(numList, i, j):     
    s = numList[j] 
    if i > 0:
        s -= numList[i-1]
    return s

maxVal = 0
numbers = list(map(int,input().split()))
n = len(numbers)

#Accumulated list
for i in range(1,n):
    numbers[i] += numbers[i-1]

for i in range(n):
    for j in range(i,n):
	    maxVal = max(maxVal, Sum(numbers, i, j))
print(maxVal)









